## 제네릭(Generic)

- 제네릭(Generic)이란?
  - 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시 타입 체크를 해주는 기능을 제공
    > *런타임 타입 체크*를 **컴파일 단계**로 끌어올린것

- 제네릭 클래스
  - static 키워드를 가질 수 없다. (메모리 생성 시점에 제네릭 타입을 정의 할 수 없기때문)
- 제네릭 메소드
  - static 키워드를 가질 수 있다.
  - 제네릭 타입의 변수는 지역 변수 처럼 동작한다.
- 와일드 카드 (범위 제한)
  - <? extends T>: 상한 제한 -> T 자신을 포함한 상속받는 하위 클래스 타입만 허용 (Upper-bound)
  - <? super T>: 하한 제한 -> T 자신을 포함한 상위 클래스 타입만 허용 (Lower-bound)
  - <?>: 모든 타입 허용 (<? extneds Object> 와 같다)

- 제네릭 타입 컨벤션
  - E: Element
  - K: Key
  - N: Number
  - T: Type
  - V: Value
  - S, U, V: 2nd, 3rd, 4th types

- PECS : "Producer Extends, Consumer Super"
  - 소비자: ? super (쓰기)
  - 생산자: ? extends (읽기)

### 제네릭 사용시 주의사항
1. 타입 소거
   제네릭은 컴파일 타임에만 유효하고 런타임에는 제거된다. 따라서 제네릭 타입의 실제 타입 인자는 런타임에는 알 수 없으며,  
   제네릭 클래스의 메서드나 생성자에서 제네릭 타입의 실제 타입 인자를 사용하려면 타입 캐스팅을 해야 한다.
2. 로(raw) 타입 사용하지 않기
   로(raw) 타입은 제네릭을 사용하지 않는 것과 같다. 따라서 가능한한 로 타입을 사용하지 않고, 제네릭 타입을 명시적으로 지정하여 
   컴파일러가 타입 안정성을 검사할 수 있도록 해야 한다.
3. 제네릭 타입 생성 불가
   제네릭 타입으로는 객체를 생성할 수 없다. 따라서 제네릭 타입의 배열을 생성하거나, 제네릭 타입으로 객체를 직접 생성하는 것은 불가능하다.
