## 객체 지향 프로그래밍(OOP)

### 객체 지향 프로그래밍 4대 요소
1. **캡슐화**
- 캡슐화(Encapsulation)란?
  - 객체의 데이터와 기능을 하나로 묶고 외부에 노출되지 않도록 숨김 처리하는 것을 말한다.  
    클래스, 변수, 메소드에 대해 접근 제어자를 사용함으로써 캡슐화를 할 수 있다.

- Getter/Setter 란?
  - 보호 받는(캡슐화) 객체의 외부에서 직접적으로 내부 데이터에 접근하는 것을 막는데   
     이는 객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성(결점이 없는 성질)이 깨어질 수 있기 때문이다.  
     하여 공개된 메서드(Getter/Setter)를 제공함으로써 데이터 제어를 허용한다.
  - getter 정의
    - 불리언 외 타입: get<변수명>
    - 불리언 타입: get<변수명> | is<변수명> | has<변수명> (의미에 따라 다양하게 작성)
  - setter 정의
    - set<변수명> (타입 매개변수) : *단일(1개)*의 매개변수만을 취한다.
    - 새로운 데이터를 저장할때 Varidation을 진행한다.
    > 공개된 메서드로 작성시 get/set 명명규칙을 사용하여 작성하는것이 관례이다.

2. **상속**
- 상속(inheritance)이란?
  - 객체 지향 프로그래밍(OOP)에서 자손 클래스가 조상 클래스의 기능을 그대로 이어받아서 재사용하는 것을 말한다.
  - 자바에서는 계승, 확장(extends)이라는 단어로 사용된다.

- 다중상속(Multiple inheritance)이란?
  - 객체 지향 프로그래밍의 특징 중 하나이며, 어떤 클래스가 하나 이상의 상위 클래스로부터 여러 가지 행동이나 특징을 상속받을 수 있는 것을 말한다.
    자바의 경우 **단일 상속(single inheritance)** 만을 허용한다.
    - 단일 상속만 허용한 이유
      - 설계상의 결정  
        자바 언어의 설계자들은 객체지향 프로그래밍의 기본 원칙 중 하나인 "단일 책임 원칙(Single Responsibility Principle)"을 따르기 위해
        단일 상속을 선택했고 이는 클래스가 한 가지 책임만을 갖도록 하여 코드의 유지보수와 확장성을 높이기 위함이었다.
      - 복잡성 증가  
        다중 상속을 허용하면 여러 부모 클래스에서 동일한 이름을 가진 메서드나 변수가 상속될 수 있다.  
        이 경우, 어떤 부모 클래스에서 상속받은 메서드나 변수를 사용해야 할 지 명확하지 않을 수 있다.
      - 다형성 구현의 어려움
        다중 상속을 허용하면 상속된 클래스들 사이에 다양한 관계가 형성될 수 있다.  
        이 경우, 상속된 클래스의 타입이 모호해질 수 있으며, 이로 인해 다형성(polymorphism)을 구현하는 데 어려움이 생길 수 있다.

- 상속 제외 3가지 경우
  1. 상속은 부모클래스로부터 멤버변수, 메소드르 상속 받는 것은 가능하지만 *생성자*는 상속이 불가능하다.
  2. 접근 제어자가 private 선언된 멤버변수와 메서드는 상속이 불가능하다.
  3. 부모클래스와 자식클래스가 다른 패키지에 존재한다면 default 접근 권한을 갖는 메소드는 상속이 불가능하다.

- super
  - 상속(부모 클래스) 객체 접근
- super()
  - 상속(부모 클래스) 객체 생성자 호출
    - :rotating_light: 생성자의 내부에서만 사용할 수 있다.
    - :rotating_light: 반드시 생성자의 첫 줄에 위치해야 한다.
    - :rotating_light:생성자 첫 줄에 super()가 없는 경우 컴파일러가 자동으로 super()를 삽입한다.  
      이때 상위클래스에 *기본 생성자*가 없으면 에러가 발생한다.

- 포함 관계
  - 포함(composite)은 상속처럼 클래스를 재사용할 수 있는 방법으로, 클래스의 멤버로 다른 클래스 타입의 참조변수를 선언하는 것을 의미한다.
  ```java
      // 포함 관계 예시
      public class A {
        private String s;
    
        public A(String s) {
            this.s = s;
        }
      }
  
      public class B {
        private String C;
        private A a;  // 클래스 타입의 멤버변수
  
        public B(String c, String a) {
          this.c = c;
          this.a = new A(a);  // 객체 생성하여 초기화
        }
      }
      
      public class C {
        public static void main(String[] args) {
          B newB = new B("has-a", "포함 관계");
        }
      }
  ```
  - 상속-포함 관계 설정
    - is-a: A~는(은) B~이다. (상속)
    - has-a: A~는(은) B~를(을) 가지고 있다. (포함)

3. **추상화**
- 추상화(Abstraction)란?
  - 사전적 의미는 사물이나 표상을 어떤 성질, 공통성, 본질에 착안하여 그것을 추출하여 파악하는 것"이라고 정의된다.  
    프로그래밍에서의 추상적 개념은 공통성(속성)과 본질(메소드)을 모아 추출하는 것을 의미한다.

- 추상 클래스(미완성 클래스)
  - 추상 메소드를 포함한 클래스
  - 추상 클래스는 의도적인 미완성 클래스로 완성된 일부를 가질 수 있다.
  - 추상 클래스를 상속하는 하위 클래스에서 미완성 부분의 구체화를 강제한다.
  - 추상 클래스는 실체(인스턴스)화 불가능하다.
  ```java
    abstract class A {
       abstract viod explicit(); // -> 추상 메소드(미완성 메소드) 의도적 미완성
    }
    
    class B extends A {
      viod explicit() {  } // -> 미완성 메소드 구체화
    }
  ```
  
- 인터페이스(interface)
  - 사전적 의미는 "-간/사이"를 뜻하는 inter와 "얼굴/면"을 의미하는 face의 결합으로 구성된 단어로, 두 개의 다른 대상 사이를 연결한다는 뜻이다.  
    프로그래밍에서의 인터페이스는 서로 다른 두 시스템, 장치, 소프트웨어 따위를 서로 이어주는 부분 또는 그런 접속 장치를 의미한다.
  - 추상 메소드의 집합이다.
  - 상속의 개념과 동일하지만 "구현하다"라는 의미를 가진 implements 키워드를 사용한다.
  - *서로 관계없는* 클래스들의 관계를 맺어줄 수 있다.

- 인터페이스 내부 정보
  - 모든 필드는 public static final로 정의된다.
  - static, default 메소드를 제외한 나머지 메소드는 public abstract로 정의된다.
  - 인터페이스를 구현하는 하위 클래스에서 미완성 부분의 구체화를 강제한다.
  - 인터페이스는 다중 상속이 가능하다. (단 인터페이스 -> 인터페이스로의 상속만 가능)
  ```java
    interface A {
      // public static final float PI = 3.14F;
      // static final float PI = 3.14F;
      // final float PI = 3.14F;
      
      // 위 3개의 정의 방식과 같은 내용이다.
      float PI = 3.14F;
      
      // public abstract explicit();
      // abstract explicit();
  
      // 위 2개의 정의 방식과 같은 내용이다.
      explicit();
      
      default void defaultMethod() {
       // 구현부를 가질 수 있다.
      }
      
      static void staticMethod() {
       // 구현부를 가질 수 있다.
      }
    }
  ```

4. **다형성**
- 다형성(Polymorphism)이란?
  - 하나의 객체가 여러 가지 형태를 가질 수 있는 성질을 의미한다.
  - 오버로딩, 오버라이딩 또한 다형성의 성질을 보여준다.
   
- 장점
  1. 여러 객체를 하나의 타입으로 관리가 가능하기때문에 코드 관리가 편리해지고 유지보수가 용이하다.
  2. 코드 재사용성이 높진다.
  3. 클래스간 의존성이 줄어들어 확장성이 높고 결합도가 낮아져 안전성이 높아진다.

- 참조 변수의 타입 변환
  - 상속 관계가 성립되어야한다. (상위 <-> 하위)
  - 하위 -> 상위 타입 변환(업캐스팅) 형변환 연산자 생략가능
  - 반대의 경우 상위 -> 하위 (다운캐스팅) 형변환 연산자 생략 불가

- 매개 변수의 타입 변환
  - 상속 관계가 성립되어야한다. (상위-하위)
  - 상속 관계가 성립된 인자를 매개변수로 취할 수 있다.
  - 업/다운 캐스트 가능 여부 확인 = 참조변수 instanceof 타입

### 객체 지향 설계 원칙 (SOLID 원칙)
1. Single Responsibility Principle (SRP) - 단일 책임 원칙
- 클래스 또는 모듈은 하나의 기능만 가져야 하며, 클래스 또는 모듈의 변경 사유는 하나여야 한다.

2. OCP 개방-폐쇄 원칙 (Open/closed principle)
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- 기존 코드를 변경하지 않고도 새로운 기능을 추가할 수 있어야 한다.

3. LSP 리스코프 치환 원칙 (Liskov substitution principle)
- 자식 클래스는 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다.
- 즉, 상속 관계에서 자식 클래스는 부모 클래스를 대체할 수 있어야 한다.

4. ISP 인터페이스 분리 원칙 (Interface segregation principle)
- 인터페이스는 사용하지 않는 메서드를 포함하지 않아야 한다.
- 즉, 인터페이스는 작고 응집력 있는 것이 좋다.

5. DIP 의존관계 역전 원칙 (Dependency inversion principle)
- 추상화에 의존해야 하며, 구체화에 의존하면 안 된다.
- 즉, 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 되며, 추상화는 구체화에 의존해서는 안 된다.

#### SOLID 원칙을 지킴으로써 얻는 이점
1. 유지보수성 향상
   코드의 각 요소들이 독립적이고, 목적과 책임이 분명해지기 때문에 코드를 이해하고 수정하기가 쉬워진다.  
   또한, 수정할 때 발생하는 오류나 버그의 발생 가능성이 줄어들어 코드의 유지보수성이 향상된다.

2. 재사용성 향상
   코드의 각 요소들이 독립적이고, 단일 책임을 가지므로 새로운 기능을 추가하거나 수정할 때 기존 코드를 재사용하고, 중복을 방지할 수 있다.  
   따라서 코드의 재사용성을 향상시키며 개발 시간과 비용을 절약할 수 있다.

3. 가독성 향상
   코드의 각 요소들이 목적과 책임이 분명해지기 때문에 코드를 읽기 쉬워진다.  
   따라서 코드의 가독성을 향상시켜 유지보수나 협업에 큰 도움이 된다.

4. 테스트성 향상
   코드의 각 요소들이 독립적이고, 단일 책임을 가지므로 테스트하기 쉬워집니다.  
   따라서 코드의 테스트성을 향상시키며, 버그나 오류를 미리 발견하여 수정할 수 있다.

5. 확장성 향상
   새로운 기능을 추가할 때 기존 코드를 수정하지 않아도 되므로, 코드의 확장성이 높아진다.  
   따라서 소프트웨어의 변화에 대응하기 쉬워지며, 시스템을 더욱 쉽게 확장할 수 있게 된다.

#### 높은 응집력이란?
비슷한 일을 하는 기능 즉, 하나의 책임(SRP)에 포함되는 기능들이 잘 뭉쳐있다면 높은 응집력을 가진다 볼 수 있다.  
하나의 기능을 변경하는데 여러 영역에서의 변경이 예상된다면 응집력이 낮다고 볼 수 있다.

#### 낮은 결합도란?
클래스 간에 의존성이 낮다면 낮은 결합도를 가진다 볼 수 있다.  
하나의 클래스를 수정하는데 의존하는 다른 클래스를 모두 수정해야 한다면 결합도가 높다고 할 수 있다.
