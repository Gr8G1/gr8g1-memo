## Collection
자바에서는 다양한 자료구조를 구현할 수 있는 컬렉션 프레임워크(Collection Framework)를 제공한다.
> 컬렉션 프레임워크는 자바에서 다양한 자료구조를 구현하는 데 사용되며, 다양한 인터페이스와 구현 클래스를 제공한다.
자바 컬렉션은 크게 List, Set, Map 으로 분류할 수 있다.

- List 
  - 순서가 있는 데이터의 집합 
  - 데이터를 인덱스로 접근할 수 있고 중복된 데이터를 허용한다.
  - 대표적인 클래스로는 ArrayList, LinkedList, Vector 등이 있다.

- Set
  - 순서가 없는 데이터의 집합 **(저장 순서를 보장하지 않는다.)**
  - 중복된 데이터를 허용하지 않는다. 
  - 대표적인 클래스로는 HashSet, LinkedHashSet, TreeSet 등이 있다.

- Map
  - Key-Value 쌍으로 이루어진 데이터의 집합 
  - Key는 중복될 수 없고, Value는 중복될 수 있다. 
  - 대표적인 클래스로는 HashMap, TreeMap, LinkedHashMap 등이 있다.

### List
- ArrayList
  - 내부적으로 배열을 이용하여 구현되어 있기 때문에, 인덱스로 데이터를 빠르게 접근할 수 있다. 
  - 데이터 조회나 추가, 수정 등의 작업에서는 매우 빠른 성능을 보이며, 대량의 데이터를 처리할 때 적합하다. 
  - 데이터 삽입이나 삭제 작업이 빈번하게 발생하는 경우, 해당 인덱스 이후의 모든 데이터를 한 칸씩 이동시켜야 하기 때문에 성능 저하될 수 있다.

- LinkedList (Queue 인터페이스를 구현한 클래스)
  - 데이터를 저장하는 노드들이 서로 연결되어 있는 형태로 구현되어 있다. 
  - 데이터의 삽입이나 삭제 작업에서는 ArrayList 에 비해 우수한 성능을 보이며, 중간에 데이터를 삽입하는 경우에도 인덱스 이동 없이 바로 삽입할 수 있다. 
  - 인덱스로 데이터를 조회하는 경우에는 전체 데이터를 탐색해야 하기 때문에 성능이 저하될 수 있다.

- Queue
  - 데이터를 일시적으로 저장하기 위한 자료구조 중 하나로 큐는 First-In-First-Out(FIFO) 구조를 가지고 있다.
  - enqueue(데이터 삽입), dequeue(데이터 삭제), peek(가장 앞에 있는 데이터 조회) 등의 메소드를 제공한다.
  - 큐에서 가장 앞에 있는 데이터를 가리키는 포인터를 front, 가장 뒤에 있는 데이터를 가리키는 포인터를 rear이라고 한다.
  - java.util 패키지를 확인해보면 Queue 인터페이스와 그 구현체인 LinkedList, PriorityQueue 등의 클래스들이 있다.

- Vector
  - ArrayList와 거의 동일한 구조를 가지고 있다. 
  - Vector는 멀티 스레드 환경에서 안전하게 동작하도록 구현되어 있다. 여러 스레드에서 Vector에 접근하여 동시에 데이터를 수정하려는 경우  
    해당 데이터에 대한 락(Lock)을 걸어 다른 스레드가 접근하지 못하도록 보호한다.

- Stack (Vector 클래스를 상속받은 클래스)
  - 데이터를 일시적으로 저장하기 위한 자료구조 중 하나로 Last-In-First-Out(LIFO) 구조를 가지고 있다.
  - push(데이터 삽입), pop(데이터 삭제), peek(가장 위에 있는 데이터 조회) 등의 메소드를 제공한다.

- ArrayList VS LinkedList
  - ArrayList
    - 배열
    - 순차적 접근시 매우 빠른 속도
  - LinkedList
    - Node 
    - 삽입/삭제시 빠른 속도
> ArrayList는 데이터를 순차적으로 접근하는 경우나 데이터의 크기가 변하지 않는 경우에 적합하며, 
> LinkedList는 데이터를 중간에 삽입하거나 삭제하는 경우에 적합하다. 
> 그리고 리스트의 크기가 매우 크거나, 데이터의 추가/삭제가 많은 경우에는 LinkedList가 더 적합할 수 있다.

### Set
중복된 값을 저장하지 않는 자료구조이므로, 데이터의 유일성을 보장하는 용도로 많이 사용된다.

- HashSet
  - 내부적으로 HashMap을 사용하여 데이터를 저장한다. 
  - 데이터를 저장하고 검색하는 속도가 매우 빠르다. 
  - 저장된 순서가 보장되지 않으며, null 값을 저장할 수 있다.
- TreeSet
  - 이진 검색 트리(Binary Search Tree)의 형태로 데이터를 저장한다. 
  - 저장된 값들이 정렬되어 저장되므로, 저장된 순서를 보장하지 않는다. 
  - 검색, 삽입, 삭제에 O(log n)의 시간 복잡도를 가지며, null 값을 저장할 수 없다.
- LinkedHashSet
  - HashSet과 비슷하지만, 내부적으로 LinkedList를 사용하여 데이터를 저장한다. 
  - 데이터를 저장한 순서대로 반복문을 사용하여 접근할 수 있다. 
  - 저장 순서가 유지되므로, HashSet보다는 삽입과 삭제 연산의 성능이 느릴 수 있다.

### Map
키-값 쌍의 데이터를 저장하는 자료구조로 맵은 키(key)를 기반으로 값을 검색하고 저장하며, 각 키는 유일해야 한다.
저장된 객체를 Entry 객체라 칭하고, Entry 객체는 K(key), V(value)를 각각 Key 객체와 Value객체로 저장한다.

- HashMap
  - 가장 기본적인 맵 구현체로, 해시 함수를 사용하여 데이터를 저장하여 매우 빠른 검색 속도를 가진다. 그러나 순서가 보장되지 않는다.
- TreeMap
  - 이진 검색 트리를 사용하여 데이터를 저장하여 데이터가 정렬되어 저장되며, 범위 검색이 가능하다. 
  - HashMap보다는 느리며, 추가적인 메모리 공간을 사용한다.
- LinkedHashMap
  - 연결 리스트와 해시 함수를 결합하여 데이터를 저장하여 데이터가 입력된 순서대로 저장되며, 순서가 보장된다. 
  - TreeMap보다는 느리며, 추가적인 메모리 공간을 사용한다.

- Map VS Set
  - Map
    - 키(Key)와 값(Value)을 쌍으로 저장하는 자료구조
    - 키는 고유하며, 중복될 수 없다.
    - 해시 테이블(Hash Table)을 기반으로 구현되어 있으며, 검색 속도가 매우 빠르기 때문에 대용량 데이터 처리에 유용
  - Set
    - 값(Value)만을 저장하는 자료구조
    - 값은 고유하며, 중복될 수 없다.
    - 해시 테이블을 기반으로 구현되어 있으며, 내부적으로는 맵과 거의 동일한 방식으로 동작
